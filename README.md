# 单测小案例

## 需求背景

1、通过接口获取用户列表
2、留下有效的用户，也就是拿到用户列表后过滤掉无效的用户。
3、把结果序列化json以后储存到localStorage中。

## 用例分析

- 我们一定会发起一个请求。
- 假设正常返回了，我们会调用过滤用户的方法
  - 返回成功后，调用过滤的方法
  - 过滤的方法能够有效的过滤无效（status不等于1）的用户
  - 过滤成功后，调用储存方法
  - 储存方法调用localStorage.setItem
- 假设没正常返回，我们会抛出一个异常

## 实现分析

根据上面的用例分析，其实我们可以先拆出来三个独立的方法和一个总成的方法用来单元测试和实现需求。

```typescript
interface UserInfo {
  id: number
  name: string
  status: number
}
//测试思路
//  真实的接口调用不确定因素太多，会干扰到我们的测试，比如服务器重启会影响我们的ci。
//  所以我们mock掉接口调用即可，模拟出成功和失败场景即可，如果想更精细，还可以模拟超时。
//  超时的情况通常我会在一些请求库的拦截器里统一处理，所以不做重复测试。
//  这部分的测试就是不必要的测试。
//  测试的时候要有一个信任边界，比如第三方库，或者数据库浏览器等终端服务，都是不需要测的。
//  不需要测的，就要通过mock等方式，剥离掉。
//异常测试：
//  接口报错时，我们也报错
//反向测试：
//  接口返回null时，给一个空数组回去
//正向测试：
//  通过mock判断正确的调用axios的get方法
//  返回我们mock的返回值
type FetchUsers = () => Promise<UserInfo[]>
//测试思路
// 该方法是一个纯函数，接口用户数组，返回用户数组。
//异常测试：
//  数组中有脏数据，比如为null或者undefined要抛异常
//正向测试：
//  传入全部status为1的用户数组，返回全部数组
//  传入部分status为1的用户数组，返回status为1的部分数组
type FilterValidUsers = (users:UserInfo[]) => UserInfo[]
//测试思路
//  接收用户数组，序列化数组，调用loccalStorage.setItem
//异常测试
//反向测试
//  其实该方法已经不需要多余的异常测试和反向测试了，因为这个方法是一个内部方法。
//  只有在filter生效后，才会去调用，而filter确保了该方法必然能够正确的执行。
//正向测试
//  正确的调用了location.setItem方法，且参数和我们预期一致
type StorageUsers = (users:UserInfo[]) => void;
//测试思路 
//  正向和反向的测试，基本上都被底层做好了。该方法只要按顺序调用上述三个方法即可。
//  这一步事实上，可以作为独立的集成测试去做了，当然建议也是可以mock一下axios的返回值，不要依赖真实接口。
//  如果要做e2e，可以配套启动个mock server，来模拟真实场景。
//  但是该步测试的分析，算是留个大家的一个小思考。
type CacheUsers = () => Promise<UserInfo[]>;
```
